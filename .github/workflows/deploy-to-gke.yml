# Name of this GitHub Actions workflow
name: Build and Deploy Flask to GKE

# When to run this pipeline
on:
  push:
    # Run on every push to the main branch
    branches:
      - main

# Environment variables available to all jobs / steps
env:
  # GCP project ID (we read it from GitHub Secrets)
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

  # GKE cluster name (from GitHub Secrets)
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}

  # GKE zone where the cluster is running (from GitHub Secrets)
  GKE_ZONE: ${{ secrets.GKE_ZONE }}

  # Artifact Registry repo where we push images
  AR_REPO: "europe-west2-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/flask-repo"

  # Logical image name (just a label we reuse)
  IMAGE_NAME: "flask-gke-demo"

jobs:
  build-and-deploy:
    # Use the latest Ubuntu runner
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the code from this GitHub repo into the runner
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Install gcloud CLI in the runner
      # We are not relying on this action for auth; we will authenticate explicitly in the next step.
      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          export_default_credentials: false

      # Step 3: Authenticate with the service account and configure Docker for Artifact Registry
      - name: Authenticate and configure Docker for Artifact Registry
        run: |
          # Write the JSON key from GitHub Secrets to a temp file
          echo '${{ secrets.GCP_SA_KEY }}' > /tmp/gcp-key.json

          # Activate the service account using the key file
          gcloud auth activate-service-account \
            --key-file=/tmp/gcp-key.json

          # Set the project (so gcloud knows which project to work with)
          gcloud config set project "$PROJECT_ID"

          # Configure Docker to use gcloud as a credential helper for Artifact Registry
          gcloud auth configure-docker europe-west2-docker.pkg.dev --quiet

      # Step 4: Enable Docker Buildx (so we can build linux/amd64 images)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 5: Build and push the Docker image for linux/amd64
      # - Tags image with the Git commit SHA
      # - Pushes it to Artifact Registry
      - name: Build and push image (linux/amd64)
        run: |
          # Build a unique image tag using the repo, name, and commit SHA
          IMAGE_TAG="${AR_REPO}/${IMAGE_NAME}:${GITHUB_SHA}"
          # Save it into the GitHub Actions environment so later steps can use it
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

          # Build and push the image for linux/amd64 (architecture used by GKE nodes)
          docker buildx build \
            --platform linux/amd64 \
            -t "$IMAGE_TAG" \
            --push .

      # Step 6: Fetch GKE credentials so kubectl talks to the right cluster
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials "$GKE_CLUSTER" \
            --zone "$GKE_ZONE"

      # Step 7: Apply Kubernetes manifests (ensure Deployment + Service exist)
      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml

      # Step 8: Update the deployment to use the new image we just built
      - name: Update deployment image
        run: |
          kubectl set image deployment/flask-gke-demo \
            flask-gke-demo="$IMAGE_TAG" \
            --namespace=default

      # Step 9: Wait for the rollout to complete (or fail) before finishing the job
      - name: Check rollout status
        run: |
          kubectl rollout status deployment/flask-gke-demo --timeout=120s