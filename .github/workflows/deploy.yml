name: Deploy Flask App to GKE

on:
  push:
    branches:
      - main       # deploy to dev on main push
    tags:
      - 'v*'       # deploy to prod on tags like v0.1.0
  workflow_dispatch:

jobs:
  # -------------------
  # Deploy to DEV
  # -------------------
  deploy-dev:
    runs-on: ubuntu-latest

    # Only when pushing to main (not tags)
    if: github.ref == 'refs/heads/main'

    # Job-level env so we can safely use secrets
    env:
      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}
      GKE_ZONE: ${{ secrets.GKE_ZONE }}
      AR_REPO: "europe-west2-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/flask-repo"
      IMAGE_NAME: "flask-gke-demo"
      K8S_NAMESPACE: "dev"

    steps:
      # ‚úÖ 1) Checkout so local action + k8s manifests are available
      - name: Checkout repo
        uses: actions/checkout@v4

      # üîê 2) Reuse shared GCP login (no Docker config needed)
      - name: GCP login
        uses: ./.github/actions/gcp-login
        with:
          service-account-key: ${{ secrets.GCP_SA_KEY }}
          configure-docker: "false"

      # 3) Get kubeconfig for the GKE cluster
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials "$GKE_CLUSTER" \
            --zone "$GKE_ZONE"

      # 4) Apply manifests into dev namespace
      - name: Apply Kubernetes manifests to dev
        run: |
          # Namespace (idempotent)
          kubectl apply -f k8s/namespace-dev.yaml

          # Config & secrets
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/configmap.yaml
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/secret.yaml

          # Core app
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/deployment.yaml
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/service.yaml

          # Scaling resources
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/hpa.yaml
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/vpa.yaml || echo "VPA apply failed ‚Äì continuing."

      # 5) Point the Deployment at the latest image
      - name: Update deployment image (dev)
        run: |
          IMAGE_TAG="${AR_REPO}/${IMAGE_NAME}:latest"

          kubectl set image deployment/flask-gke-demo \
            flask-gke-demo="$IMAGE_TAG" \
            --namespace="$K8S_NAMESPACE"

      # 6) Block until rollout finishes (or fails)
      - name: Check rollout status (dev)
        run: |
          kubectl rollout status deployment/flask-gke-demo \
            --namespace="$K8S_NAMESPACE" \
            --timeout=180s

  # -------------------
  # Deploy to PROD
  # -------------------
  deploy-prod:
    runs-on: ubuntu-latest

    # Only when pushing tags like v0.1.0
    if: startsWith(github.ref, 'refs/tags/v')

    # Attach to GitHub Environment "prod" for manual approval
    environment:
      name: prod

    # Job-level env with secrets + prod namespace
    env:
      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}
      GKE_ZONE: ${{ secrets.GKE_ZONE }}
      AR_REPO: "europe-west2-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/flask-repo"
      IMAGE_NAME: "flask-gke-demo"
      K8S_NAMESPACE: "prod"

    steps:
      # ‚úÖ 1) Checkout so local action + k8s manifests are available
      - name: Checkout repo
        uses: actions/checkout@v4

      # üîê 2) Reuse shared GCP login
      - name: GCP login
        uses: ./.github/actions/gcp-login
        with:
          service-account-key: ${{ secrets.GCP_SA_KEY }}
          configure-docker: "false"

      # 3) Get kubeconfig for the GKE cluster
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials "$GKE_CLUSTER" \
            --zone "$GKE_ZONE"

      # 4) Apply manifests into prod namespace
      - name: Apply Kubernetes manifests to prod
        run: |
          # Namespace
          kubectl apply -f k8s/namespace-prod.yaml

          # Config & secrets
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/configmap.yaml
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/secret.yaml

          # Core app
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/deployment.yaml
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/service.yaml

          # Scaling resources
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/hpa.yaml
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/vpa.yaml || echo "VPA apply failed ‚Äì continuing."

      # 5) Point the Deployment at the latest image
      - name: Update deployment image (prod)
        run: |
          IMAGE_TAG="${AR_REPO}/${IMAGE_NAME}:latest"

          kubectl set image deployment/flask-gke-demo \
            flask-gke-demo="$IMAGE_TAG" \
            --namespace="$K8S_NAMESPACE"

      # 6) Block until rollout finishes (or fails)
      - name: Check rollout status (prod)
        run: |
          kubectl rollout status deployment/flask-gke-demo \
            --namespace="$K8S_NAMESPACE" \
            --timeout=180s